<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stage Lighting Planner</title>
    <style>
        /* Add loading screen styles at the top */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }

        .loading-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .loading-content {
            text-align: center;
        }

        .loading-logo {
            width: 200px;
            height: auto;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Hide main content initially */
        .main-content {
            opacity: 0;
            transition: opacity 0.5s ease-in;
        }

        .main-content.visible {
            opacity: 1;
        }

        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #333;
            font-family: Arial, sans-serif;
        }

        .stage-container {
            position: relative;
            width: 90vw;  /* Changed from fixed width to viewport width */
            max-width: 1300px;
            height: 60vh;  /* Changed from fixed height to viewport height */
            max-height: 600px;
            margin-top: -50vh;  /* Changed from -20vh to move stage higher up */
            perspective: 1000px;
        }

        .stage-floor {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 400px;
            background: linear-gradient(to bottom right, #8b4513, #6b2d0f);
            box-shadow: 0 20px 30px rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 0 2vw;  /* Changed from fixed padding to viewport width */
            transform: perspective(1000px) rotateX(5deg);
            transform-origin: bottom;
        }

        .spotlight-location {
            width: clamp(100px, 15vw, 180px);  /* Responsive width */
            height: clamp(100px, 15vw, 180px);  /* Responsive height */
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 1.2em;
            text-shadow: 1px 1px 2px #000;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            margin: 0 px;  /* Reverted back to original */
        }

        .spotlight-location:hover {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
            z-index: 1;
        }

        #spotlight-4 {
            margin-right: -80px;
            z-index: 2;
        }

        #spotlight-5 {
            margin-left: -80px;
        }

        .stage-label {
            position: absolute;
            color: white;
            font-size: 1.5em;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        #stage-left {
            left: 50px;
            bottom: 60%;
            transform: translateY(100%);
        }

        #stage-right {
            right: 10px;
            bottom: 60%;
            transform: translateY(100%);
        }

        .control-panel-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000;
        }

        .control-panel {
            position: fixed;
            bottom: -400px; /* Increased from -300px */
            left: 0;
            width: 100%;
            height: 400px; /* Increased from 300px */
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            box-sizing: border-box;
            transition: bottom 0.2s ease;
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 20px;
            z-index: 997;
        }

        .control-panel.open {
            bottom: 0;
        }

        .scene-manager {
            border-right: 1px solid #444;
            padding-right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;  /* Added */
            position: relative;  /* Added */
        }

        .scene-list {
            flex-grow: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            padding: 10px;
            overflow-y: auto;
            margin-bottom: 10px;  /* Added */
            max-height: 280px; /* Increased height */
        }

        .scene-item {
            padding: 8px;
            background: #444;
            border-radius: 4px;
            margin-bottom: 5px;
            color: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .scene-item:hover {
            background: #555;
        }

        .scene-item.active {
            background: #666;
            border: 1px solid #888;
        }

        .scene-controls {
            display: flex;
            gap: 5px;
            margin-top: auto;  /* Added */
            padding-top: 10px;  /* Added */
            border-top: 1px solid #444;  /* Added */
        }

        .scene-button {
            padding: 5px 10px;
            background: #444;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .scene-button:hover {
            background: #555;
        }

        .slider-panel {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            width: 60px;
            height: 180px;
            position: relative;
            margin: 0 15px;
            padding: 20px 0;
        }

        .brightness-input {
            width: 40px;
            padding: 2px 4px;
            border: 1px solid #555;
            border-radius: 3px;
            background: #333;
            color: white;
            text-align: center;
            font-size: 0.9em;
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .brightness-input::-webkit-inner-spin-button {
            opacity: 1;
        }

        .slider-container input[type="range"] {
            position: absolute;
            -webkit-appearance: none;
            appearance: none;
            width: 150px;
            height: 4px;
            background: #555;
            transform: rotate(270deg);
            transform-origin: center;
            left: -45px;
            top: 75px;
            transition: all 0.5s ease;
            min-width: 150px;
            -webkit-appearance: none;
        }

        .slider-label {
            position: absolute;
            bottom: 30px;
            color: white;
            text-align: center;
            width: 100%;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
        }

        .scene-button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        .more-options {
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
        }

        .more-options:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .dropdown-menu {
            position: absolute;
            right: 0;
            background: #333;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
            min-width: 120px;
            max-width: 150px;
            font-size: 0.9em;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            padding: 6px 12px;
            color: white;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dropdown-item:hover {
            background: #444;
        }

        .audience-label {
            position: absolute;
            bottom: -40px;  /* Changed from bottom: 10px to move it below the stage */
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 1.5em;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        .stage-monitor {
            position: absolute;
            width: 40px;
            height: 30px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.9);
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            transform: perspective(500px) rotateX(5deg);
        }

        #monitor-left {
            left: 15%;  /* Reverted back to original */
            bottom: 5%;
        }

        #monitor-right {
            right: 15%;  /* Reverted back to original */
            bottom: 5%;
        }

        .props-panel {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;  /* Increased from 15px */
            border-radius: 12px;  /* Increased from 8px */
            display: flex;
            flex-direction: column;
            gap: 15px;  /* Increased from 10px */
            z-index: 100;
        }

        .prop-item {
            width: clamp(40px, 8vw, 60px);  /* Responsive width */
            height: clamp(40px, 8vw, 60px);  /* Responsive height */
            background: white;
            border-radius: 8px;  /* Increased from 4px */
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(24px, 4vw, 32px);  /* Responsive font size */
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;  /* Increased from 2px */
            padding: 8px;  /* Increased from 5px */
            height: auto;
        }

        .prop-item small {
            font-size: 12px;  /* Increased from 10px */
            opacity: 0.8;
            color: black;
        }

        .stage-prop {
            position: absolute;
            cursor: move;
            z-index: 10;
        }

        .prop-chair {
            width: 30px;
            height: 30px;
            background: black;  /* Already black */
        }

        .prop-table {
            width: 60px;
            height: 40px;
            background: #2e8b57;  /* Changed to sea green */
        }

        .prop-mic {
            width: 8px;
            height: 40px;
            background: #1e90ff;  /* Changed to dodger blue */
            border-radius: 4px;
        }

        .prop-mic-stand {
            width: 8px;
            height: 40px;
            background: #1e90ff;  /* Changed to dodger blue */
            border-radius: 4px;
        }

        .prop-mic-stand::after {
            content: '';
            position: absolute;
            top: 0;
            left: -6px;
            width: 20px;
            height: 20px;
            background: #1e90ff;  /* Changed to dodger blue */
            border-radius: 50%;
        }

        .prop-mic-condenser {
            width: 15px;
            height: 40px;
            background: #1e90ff;  /* Changed to dodger blue */
            border-radius: 4px;
        }

        .export-pdf-button {
            position: fixed;
            bottom: 20px;
            right: 160px;  /* Position it to the left of control panel button */
            padding: 10px 20px;
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000;
        }

        .export-pdf-button:hover {
            background: #555;
        }

        @media (max-width: 768px) {
            .stage-label {
                font-size: 1.2em;
            }

            .audience-label {
                font-size: 1.2em;
            }

            .control-panel-button,
            .export-pdf-button {
                padding: 8px 15px;
                font-size: 0.9em;
            }

            .scene-controls {
                flex-wrap: wrap;
                justify-content: center;
            }
        }

        @media (min-width: 769px) and (max-width: 1024px) {
            .stage-container {
                width: 95vw;
                height: 65vh;
            }

            .props-panel {
                padding: 15px;
            }
        }

        @media (orientation: landscape) and (max-height: 600px) {
            .stage-container {
                margin-top: -30vh;  /* Adjusted for landscape mode */
                height: 50vh;
            }
        }

        .pagination-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        .page-button {
            padding: 5px 10px;
            background: #444;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .page-button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        .page-indicator {
            color: white;
            display: flex;
            align-items: center;
        }

        .control-buttons {
            margin-bottom: 10px;  /* Added */
        }

        .scene-list-container {
            flex-grow: 1;  /* Added */
            display: flex;  /* Added */
            flex-direction: column;  /* Added */
            height: calc(100% - 60px); /* Adjusted for better spacing */
            overflow: hidden;  /* Added */
        }

        .autoplay-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .autoplay-button {
            padding: 8px 15px;
            background: #444;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .autoplay-button.playing {
            background: #666;
        }

        .autoplay-settings {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
        }

        .autoplay-settings label {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Highlight active scene during autoplay */
        .scene-item.autoplay-active {
            background: #557;
            border-color: #779;
        }

        .scene-transition {
            color: #aaa;
            font-size: 0.8em;
            margin: 0 8px;
        }

        .scene-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: #444;
            border-radius: 4px;
            margin-bottom: 5px;
            color: white;
            cursor: pointer;
        }

        .scene-name {
            flex-grow: 1;
        }

        .trash-bin {
            position: fixed;
            bottom: 73%;  /* Changed from bottom: 20px */
            left: 50px;
            width: 50px;
            height: 50px;
            background: rgba(255, 0, 0, 0.2);
            border: 2px dashed #ff0000;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            z-index: 1000;
            transition: all 0.3s ease;
            transform: translateY(50%);  /* Added to center vertically */
        }

        .trash-bin.drag-over {
            background: rgba(255, 0, 0, 0.4);
            transform: scale(1.1);
        }

        .trash-bin.hidden {
            display: none;
        }

        /* Added credits style */
        .credits {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 1rem;
            z-index: 10000;
        }
    </style>
    
    <!-- Add these scripts in the head section -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
    <!-- Added credits element -->
    <div class="credits">Developed By Ryan Yeung - Head of Stage Management Team 24-25</div>
    
    <!-- Add loading screen -->
    <div class="loading-screen">
        <div class="loading-content">
            <img src="sitefile/logo.png" alt="Logo" class="loading-logo">
        </div>
    </div>

    <!-- Wrap existing content in main-content div -->
    <div class="main-content">
        <div class="stage-container">
            <div class="stage-floor">
                <div class="stage-monitor" id="monitor-left"></div>
                <div class="stage-monitor" id="monitor-right"></div>
                <!-- Fix spotlight classes -->
                <div class="spotlight-location" id="spotlight-1">1</div>
                <div class="spotlight-location" id="spotlight-2">2</div>
                <div class="spotlight-location" id="spotlight-3">3</div>
                <div class="spotlight-location" id="spotlight-4">4</div>
                <div class="spotlight-location" id="spotlight-5">5</div>
                <div class="spotlight-location" id="spotlight-6">6</div>
                <div class="spotlight-location" id="spotlight-7">7</div>
                <div class="spotlight-location" id="spotlight-8">8</div>
            </div>

            <!-- Stage Labels -->
            <div class="stage-label" id="stage-right">Stage Left</div>
            <div class="stage-label" id="stage-left">Stage Right</div>

            <div class="audience-label">Audience</div>
        </div>
        <button class="control-panel-button">Control Panel</button>
        <div class="control-panel">
            <div class="scene-manager">
                <div class="control-buttons">
                    <button class="export-pdf-button">Export Layout PDF</button>
                    <!-- Add autoplay controls -->
                    <div class="autoplay-controls">
                        <button class="autoplay-button">Autoplay</button>
                        <div class="autoplay-settings">
                            <label>
                                <input type="checkbox" id="loop-autoplay" checked>
                                Loop
                            </label>
                        </div>
                    </div>
                </div>
                <!-- Add a container for the scrollable scene list -->
                <div class="scene-list-container">
                    <div class="scene-list" id="sceneList">
                        <!-- Scenes will be added here dynamically -->
                    </div>
                    <div class="pagination-controls">
                        <button class="page-button" id="prevPage">←</button>
                        <span class="page-indicator">Page <span id="currentPage">1</span></span>
                        <button class="page-button" id="nextPage">→</button>
                    </div>
                </div>
                <div class="scene-controls">
                    <button class="scene-button" id="createScene">Create</button>
                    <button class="scene-button" id="saveScene" disabled>Save</button>
                    <button class="scene-button" id="exportScenes">Export</button>
                    <button class="scene-button" id="importScenes">Import</button>
                    <input type="file" id="importFile" class="hidden-file-input" accept=".json">
                </div>
            </div>
            <div class="slider-panel">
                <div class="slider-container">
                    <span class="slider-label">1</span>
                    <input type="range" min="0" max="10" value="10" class="spotlight-slider" data-spotlight="1">
                    <input type="number" min="0" max="10" value="10" class="brightness-input">
                </div>
                <div class="slider-container">
                    <span class="slider-label">2</span>
                    <input type="range" min="0" max="10" value="10" class="spotlight-slider" data-spotlight="2">
                    <input type="number" min="0" max="10" value="10" class="brightness-input">
                </div>
                <div class="slider-container">
                    <span class="slider-label">3</span>
                    <input type="range" min="0" max="10" value="10" class="spotlight-slider" data-spotlight="3">
                    <input type="number" min="0" max="10" value="10" class="brightness-input">
                </div>
                <div class="slider-container">
                    <span class="slider-label">4</span>
                    <input type="range" min="0" max="10" value="10" class="spotlight-slider" data-spotlight="4">
                    <input type="number" min="0" max="10" value="10" class="brightness-input">
                </div>
                <div class="slider-container">
                    <span class="slider-label">5</span>
                    <input type="range" min="0" max="10" value="10" class="spotlight-slider" data-spotlight="5">
                    <input type="number" min="0" max="10" value="10" class="brightness-input">
                </div>
                <div class="slider-container">
                    <span class="slider-label">6</span>
                    <input type="range" min="0" max="10" value="10" class="spotlight-slider" data-spotlight="6">
                    <input type="number" min="0" max="10" value="10" class="brightness-input">
                </div>
                <div class="slider-container">
                    <span class="slider-label">7</span>
                    <input type="range" min="0" max="10" value="10" class="spotlight-slider" data-spotlight="7">
                    <input type="number" min="0" max="10" value="10" class="brightness-input">
                </div>
                <div class="slider-container">
                    <span class="slider-label">8</span>
                    <input type="range" min="0" max="10" value="10" class="spotlight-slider" data-spotlight="8">
                    <input type="number" min="0" max="10" value="10" class="brightness-input">
                </div>
            </div>
        </div>

        <div class="props-panel">
            <div class="prop-item" data-prop="chair" title="Chair">
                🪑
                <small>Chair</small>
            </div>
            <div class="prop-item" data-prop="table" title="Table">
                📋
                <small>Table</small>
            </div>
            <div class="prop-item" data-prop="mic-stand" title="Straight Mic">
                🎤
                <small>Mic</small>
            </div>
            <div class="prop-item" data-prop="mic-condenser" title="Condenser Mic">
                🎙️
                <small><Cap></Cap>Condenser</small>
            </div>
        </div>
    </div>

    <div class="trash-bin hidden" id="trashBin">🗑️</div>

    <script src="dragndrop.js"></script>
    <script>
        // Add loading screen handler at the start of your scripts
        window.addEventListener('load', () => {
            setTimeout(() => {
                document.querySelector('.loading-screen').classList.add('fade-out');
                document.querySelector('.main-content').classList.add('visible');
                
                // Remove loading screen after animation
                setTimeout(() => {
                    document.querySelector('.loading-screen').remove();
                }, 500);
            }, 1500); // Show loading screen for 1.5 seconds
        });

        const controlPanelButton = document.querySelector('.control-panel-button');
        const controlPanel = document.querySelector('.control-panel');
        const sliders = document.querySelectorAll('.spotlight-slider');

        controlPanelButton.addEventListener('click', () => {
            controlPanel.classList.toggle('open');
        });

        sliders.forEach(slider => {
            const container = slider.parentElement;
            const numberInput = container.querySelector('.brightness-input');
            
            slider.addEventListener('input', (e) => {
                const value = e.target.value;
                numberInput.value = value;
                updateSpotlightOpacity(slider, value);
            });

            numberInput.addEventListener('input', (e) => {
                let value = parseInt(e.target.value);
                value = Math.min(10, Math.max(0, value));
                e.target.value = value;
                slider.value = value;
                updateSpotlightOpacity(slider, value);
            });
        });

        function updateSpotlightOpacity(slider, value) {
            const spotlightNum = slider.dataset.spotlight;
            const spotlight = document.querySelector(`#spotlight-${spotlightNum}`);
            const opacity = value / 10;
            spotlight.style.opacity = opacity;
        }

        const sceneList = document.getElementById('sceneList');
        const createSceneBtn = document.getElementById('createScene');
        const saveSceneBtn = document.getElementById('saveScene');
        const exportScenesBtn = document.getElementById('exportScenes');
        const importScenesBtn = document.getElementById('importScenes');
        const importFile = document.getElementById('importFile');
        
        let scenes = JSON.parse(localStorage.getItem('scenes') || '{}');
        let currentScene = null;

        let currentPage = 1;
        const scenesPerPage = 4;

        function updateScenesList() {
            sceneList.innerHTML = '';
            saveSceneBtn.disabled = !currentScene;
            
            const sceneNames = Object.keys(scenes);
            const totalScenes = sceneNames.length;
            const totalPages = Math.ceil(totalScenes / scenesPerPage);
            
            // Ensure current page is valid
            if (currentPage > totalPages) {
                currentPage = Math.max(1, totalPages);
            }
            
            const startIdx = (currentPage - 1) * scenesPerPage;
            const endIdx = startIdx + scenesPerPage;
            const currentScenes = sceneNames.slice(startIdx, endIdx);
            
            // Update pagination controls
            document.getElementById('currentPage').textContent = currentPage;
            document.getElementById('prevPage').disabled = currentPage <= 1;
            document.getElementById('nextPage').disabled = currentPage >= totalPages && currentScenes.length >= 4;
            
            // Always enable create button - removed the disable condition
            createSceneBtn.disabled = false;
            
            currentScenes.forEach(sceneName => {
                const sceneDiv = document.createElement('div');
                sceneDiv.className = 'scene-item';
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'scene-name';
                nameSpan.textContent = sceneName;
                
                // Add transition time display
                const transitionSpan = document.createElement('span');
                transitionSpan.className = 'scene-transition';
                transitionSpan.textContent = `${scenes[sceneName].transitionTime || 5}s`;
                
                const moreButton = document.createElement('span');
                moreButton.className = 'more-options';
                moreButton.textContent = '•••';
                moreButton.onclick = (e) => {
                    e.stopPropagation();
                    showDropdownMenu(e, sceneName);
                };
                
                if (currentScene === sceneName) {
                    sceneDiv.classList.add('active');
                }
                
                sceneDiv.appendChild(nameSpan);
                sceneDiv.appendChild(transitionSpan);
                sceneDiv.appendChild(moreButton);
                sceneDiv.onclick = () => loadScene(sceneName);
                sceneList.appendChild(sceneDiv);
            });
        }

        function showDropdownMenu(event, sceneName) {
            event.stopPropagation();
            
            const existing = document.querySelector('.dropdown-menu');
            if (existing) existing.remove();
            
            const dropdown = document.createElement('div');
            dropdown.className = 'dropdown-menu show';
            
            const items = [
                { text: 'Set Transition', action: () => setSceneTransition(sceneName) },
                { text: 'Duplicate', action: () => duplicateScene(sceneName) },
                { text: 'Rename', action: () => renameScene(sceneName) },
                { text: 'Delete', action: () => deleteScene(sceneName) }
            ];
            
            items.forEach(item => {
                const div = document.createElement('div');
                div.className = 'dropdown-item';
                div.textContent = item.text;
                div.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    item.action();
                    dropdown.remove();
                };
                dropdown.appendChild(div);
            });

            const rect = event.target.getBoundingClientRect();
            const spaceBelow = window.innerHeight - rect.bottom;
            const spaceRight = window.innerWidth - rect.left;
            
            dropdown.style.position = 'fixed';
            
            if (spaceBelow < 150) {
                dropdown.style.bottom = `${window.innerHeight - rect.top + 5}px`;
            } else {
                dropdown.style.top = `${rect.bottom + 5}px`;
            }
            
            if (spaceRight < 150) {
                dropdown.style.right = `${window.innerWidth - rect.right}px`;
            } else {
                dropdown.style.left = `${rect.left}px`;
            }
            
            document.body.appendChild(dropdown);
            
            setTimeout(() => {
                document.addEventListener('click', function closeDropdown() {
                    dropdown.remove();
                    document.removeEventListener('click', closeDropdown);
                }, { once: true });
            }, 0);
        }

        function setSceneTransition(sceneName) {
            const currentTime = scenes[sceneName].transitionTime || 5;
            const newTime = prompt('Enter transition time in seconds:', currentTime);
            if (newTime && !isNaN(newTime)) {
                scenes[sceneName].transitionTime = Math.max(1, parseInt(newTime));
                localStorage.setItem('scenes', JSON.stringify(scenes));
                updateScenesList();
            }
        }

        function duplicateScene(sceneName = currentScene) {
            if (!sceneName) return;
            
            const sceneCount = Object.keys(scenes).length;
            if (sceneCount >= 4) {
                alert('Maximum limit of 4 scenes reached. Please delete a scene before duplicating.');
                return;
            }
            
            const baseName = sceneName;
            let newName = `${baseName} (copy)`;
            let counter = 1;
            
            while (scenes[newName]) {
                counter++;
                newName = `${baseName} (copy ${counter})`;
            }
            
            scenes[newName] = JSON.parse(JSON.stringify(scenes[baseName]));
            localStorage.setItem('scenes', JSON.stringify(scenes));
            currentScene = newName;
            updateScenesList();
        }

        function renameScene(sceneName = currentScene) {
            if (!sceneName) return;
            
            const newName = prompt('Enter new scene name:', sceneName);
            if (!newName || newName === sceneName) return;
            
            if (scenes[newName]) {
                alert('A scene with this name already exists');
                return;
            }
            
            scenes[newName] = scenes[sceneName];
            delete scenes[sceneName];
            localStorage.setItem('scenes', JSON.stringify(scenes));
            currentScene = newName;
            updateScenesList();
        }

        function deleteScene(sceneName = currentScene) {
            if (!sceneName) return;
            
            if (confirm(`Are you sure you want to delete scene "${sceneName}"?`)) {
                delete scenes[sceneName];
                localStorage.setItem('scenes', JSON.stringify(scenes));
                currentScene = null;
                updateScenesList();
                
                // Re-enable create button if we're below the limit
                if (Object.keys(scenes).length < 4) {
                    createSceneBtn.disabled = false;
                    createSceneBtn.title = '';
                }
            }
        }

        function getSceneData() {
            const sceneData = {
                spotlights: {},
                props: [],
                transitionTime: 5 // Default transition time
            };
            
            // Get spotlight values - Fixed to ensure proper value capture
            document.querySelectorAll('.spotlight-slider').forEach(slider => {
                const spotlightNum = slider.dataset.spotlight;
                const value = parseInt(slider.value) || 0;
                sceneData.spotlights[spotlightNum] = value;
            });
            
            // Get prop positions
            document.querySelectorAll('.stage-prop').forEach(prop => {
                sceneData.props.push({
                    type: prop.className.split('prop-')[1],
                    left: prop.style.left,
                    top: prop.style.top
                });
            });
            
            return sceneData;
        }

        function createScene() {
            const sceneName = prompt('Enter scene name:');
            if (!sceneName) return;
            if (scenes[sceneName]) {
                alert('A scene with this name already exists');
                return;
            }

            scenes[sceneName] = getSceneData();
            localStorage.setItem('scenes', JSON.stringify(scenes));
            currentScene = sceneName;

            // Calculate total scenes and adjust current page
            const totalScenes = Object.keys(scenes).length;
            const newPage = Math.ceil(totalScenes / scenesPerPage);
            
            // Move to new page if current page is full
            const currentPageScenes = Object.keys(scenes).slice((currentPage - 1) * scenesPerPage, currentPage * scenesPerPage);
            if (currentPageScenes.length >= 4) {
                currentPage = newPage;
            }
            
            updateScenesList();
        }

        function saveScene() {
            if (!currentScene) return;
            scenes[currentScene] = getSceneData();
            localStorage.setItem('scenes', JSON.stringify(scenes));
            alert('Scene saved successfully');
        }

        function animateSlider(slider, targetValue) {
            return new Promise(resolve => {
                const startValue = parseInt(slider.value);
                const startTime = performance.now();
                const duration = 500;

                function updateValue(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    const easeProgress = progress < .5 ? 
                        4 * progress * progress * progress : 
                        1 - Math.pow(-2 * progress + 2, 3) / 2;

                    const currentValue = Math.round(startValue + (targetValue - startValue) * easeProgress);
                    slider.value = currentValue;
                    
                    const spotlightNum = slider.dataset.spotlight;
                    const spotlight = document.querySelector(`#spotlight-${spotlightNum}`);
                    const opacity = currentValue / 10;
                    spotlight.style.opacity = opacity;

                    const container = slider.parentElement;
                    const numberInput = container.querySelector('.brightness-input');
                    numberInput.value = currentValue;

                    if (progress < 1) {
                        requestAnimationFrame(updateValue);
                    } else {
                        resolve();
                    }
                }

                requestAnimationFrame(updateValue);
            });
        }

        async function loadScene(sceneName) {
            const sceneData = scenes[sceneName];
            if (!sceneData) return;

            const animationPromises = [];

            // Clear existing props
            document.querySelectorAll('.stage-prop').forEach(prop => prop.remove());

            // Load props
            if (sceneData.props) {
                sceneData.props.forEach(prop => {
                    const stageProp = document.createElement('div');
                    stageProp.className = `stage-prop prop-${prop.type}`;
                    stageProp.style.left = prop.left;
                    stageProp.style.top = prop.top;
                    document.querySelector('.stage-floor').appendChild(stageProp);
                    makeElementDraggable(stageProp);
                });
            }

            // Load spotlight values - Fixed to ensure proper value assignment
            const spotlightData = sceneData.spotlights || {};
            document.querySelectorAll('.spotlight-slider').forEach(slider => {
                const spotlightNum = slider.dataset.spotlight;
                const targetValue = Math.min(10, Math.max(0, spotlightData[spotlightNum] || 0));
                
                // Update the corresponding number input
                const container = slider.parentElement;
                const numberInput = container.querySelector('.brightness-input');
                numberInput.value = targetValue;
                
                const promise = animateSlider(slider, targetValue);
                animationPromises.push(promise);
            });

            await Promise.all(animationPromises);
            currentScene = sceneName;
            updateScenesList();
        }

        function makeElementDraggable(element) {
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            
            // Mouse events
            element.addEventListener('mousedown', startDragging);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDragging);
            
            // Touch events
            element.addEventListener('touchstart', handleTouchStart);
            document.addEventListener('touchmove', handleTouchMove);
            document.addEventListener('touchend', handleTouchEnd);
            
            function handleTouchStart(e) {
                const touch = e.touches[0];
                initialX = touch.clientX - element.offsetLeft;
                initialY = touch.clientY - element.offsetTop;
                isDragging = true;
                handleDragStart();
            }
            
            function handleTouchMove(e) {
                if (isDragging) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    currentX = touch.clientX - initialX;
                    currentY = touch.clientY - initialY;
                    element.style.left = `${currentX}px`;
                    element.style.top = `${currentY}px`;
                    handleDrag(touch.clientX, touch.clientY);
                }
            }
            
            function handleTouchEnd(e) {
                if (isDragging) {
                    const touch = e.changedTouches[0];
                    handleDragEnd(touch.clientX, touch.clientY);
                }
                isDragging = false;
            }
            
            function startDragging(e) {
                initialX = e.clientX - element.offsetLeft;
                initialY = e.clientY - element.offsetTop;
                isDragging = true;
                handleDragStart();
            }
            
            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    element.style.left = `${currentX}px`;
                    element.style.top = `${currentY}px`;
                    handleDrag(e.clientX, e.clientY);
                }
            }
            
            function stopDragging(e) {
                if (isDragging) {
                    handleDragEnd(e.clientX, e.clientY);
                }
                isDragging = false;
            }

            const trashBin = document.getElementById('trashBin');
        
            function showTrashBin() {
                trashBin.classList.remove('hidden');
            }
            
            function hideTrashBin() {
                trashBin.classList.remove('drag-over');
                trashBin.classList.add('hidden');
            }

            function handleDragStart() {
                showTrashBin();
            }

            function handleDrag(x, y) {
                const trashRect = trashBin.getBoundingClientRect();
                const isOverTrash = x >= trashRect.left && x <= trashRect.right && 
                                  y >= trashRect.top && y <= trashRect.bottom;
                
                if (isOverTrash) {
                    trashBin.classList.add('drag-over');
                } else {
                    trashBin.classList.remove('drag-over');
                }
            }

            function handleDragEnd(x, y) {
                const trashRect = trashBin.getBoundingClientRect();
                const isOverTrash = x >= trashRect.left && x <= trashRect.right && 
                                  y >= trashRect.top && y <= trashRect.bottom;
                
                if (isOverTrash) {
                    element.remove();
                    if (currentScene) {
                        saveSceneBtn.disabled = false;
                    }
                }
                hideTrashBin();
            }
        }

        function exportScenes() {
            const scenesData = {
                scenes: scenes,
                exportDate: new Date().toISOString(),
                version: "1.0"
            };

            const blob = new Blob([JSON.stringify(scenesData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `lighting-scenes-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Updated importScenes function
        function importScenes(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (!data.scenes || !data.version) {
                        throw new Error('Invalid file format');
                    }
                    
                    const importedScenes = data.scenes;
                    const sceneNames = Object.keys(importedScenes);
                    if (sceneNames.length === 0) {
                        alert('No scenes found in file');
                        return;
                    }
                    
                    sceneNames.forEach(sceneName => {
                        const sceneData = importedScenes[sceneName];
                        
                        // Clamp spotlight values if available
                        if (sceneData.spotlights) {
                            Object.keys(sceneData.spotlights).forEach(spot => {
                                sceneData.spotlights[spot] = Math.min(10, Math.max(0, sceneData.spotlights[spot]));
                            });
                        }
                        
                        // Normalize transitionTime
                        if (sceneData.transitionTime) {
                            sceneData.transitionTime = Math.max(1, parseInt(sceneData.transitionTime)) || 5;
                        } else {
                            sceneData.transitionTime = 5;
                        }
                        
                        // Leave props as-is
                    });
                    
                    const existingNames = Object.keys(scenes).filter(name => sceneNames.includes(name));
                    if (existingNames.length > 0) {
                        if (!confirm(`The following scenes will be overwritten:\n${existingNames.join(', ')}\n\nContinue?`)) {
                            return;
                        }
                    }
                    
                    scenes = { ...scenes, ...importedScenes };
                    localStorage.setItem('scenes', JSON.stringify(scenes));
                    updateScenesList();
                    alert(`Successfully imported ${sceneNames.length} scenes`);
                } catch (error) {
                    alert('Error importing scenes: ' + error.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        createSceneBtn.onclick = createScene;
        saveSceneBtn.onclick = saveScene;

        updateScenesList();

        document.getElementById('prevPage').addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                updateScenesList();
            }
        });

        document.getElementById('nextPage').addEventListener('click', () => {
            const totalScenes = Object.keys(scenes).length;
            const totalPages = Math.ceil(totalScenes / scenesPerPage);
            if (currentPage < totalPages) {
                currentPage++;
                updateScenesList();
            }
        });

        document.querySelectorAll('.prop-item').forEach(prop => {
            const createProp = (clientX, clientY) => {
                const type = prop.dataset.prop;
                const stageProp = document.createElement('div');
                stageProp.className = `stage-prop prop-${type}`;
                
                const stageFloor = document.querySelector('.stage-floor');
                const stageRect = stageFloor.getBoundingClientRect();
                
                // Calculate center position of stage
                const centerX = stageRect.left + (stageRect.width / 2);
                const centerY = stageRect.top + (stageRect.height / 3);
                
                stageProp.style.left = `${centerX}px`;
                stageProp.style.top = `${centerY}px`;
                
                stageFloor.appendChild(stageProp);
                makeElementDraggable(stageProp);
            };

            // Mouse event
            prop.addEventListener('mousedown', (e) => {
                createProp(e.clientX, e.clientY);
            });

            // Touch event
            prop.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent duplicate events
                const touch = e.touches[0];
                createProp(touch.clientX, touch.clientY);
            });
        });

        // Add PDF export functionality
        function exportLayoutPDF() {
            const stageContainer = document.querySelector('.stage-container');
            
            // Temporarily hide spotlights for the capture
            const spotlights = document.querySelectorAll('.spotlight-location');
            spotlights.forEach(spot => spot.style.display = 'none');
            
            html2canvas(stageContainer).then(canvas => {
                // Restore spotlights
                spotlights.forEach(spot => spot.style.display = '');
                
                // Count props
                const propCounts = {};
                document.querySelectorAll('.stage-prop').forEach(prop => {
                    const type = prop.className.split('prop-')[1];
                    propCounts[type] = (propCounts[type] || 0) + 1;
                });
                
                // Create PDF in portrait orientation with more space for inventory
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'px',
                    format: [canvas.width, canvas.height + 400] // Doubled space for inventory
                });
                
                // Scale down the image to fit portrait orientation
                const scale = pdf.internal.pageSize.width / canvas.width;
                const scaledHeight = canvas.height * scale;
                
                // Add stage image
                pdf.addImage(
                    canvas.toDataURL('image/png'), 
                    'PNG', 
                    0, 
                    0, 
                    pdf.internal.pageSize.width, 
                    scaledHeight
                );
                
                // Add inventory count with larger font
                pdf.setFontSize(36); // Increased from 24
                pdf.setFont("helvetica", "bold");
                pdf.text('Stage Layout Inventory:', 20, scaledHeight + 60); // Increased spacing
                
                pdf.setFontSize(28); // Increased from 18
                pdf.setFont("helvetica", "normal");
                let yPos = scaledHeight + 120; // Increased initial spacing
                for (const [prop, count] of Object.entries(propCounts)) {
                    // Format prop name to be more readable
                    const propName = prop.split('-').map(word => 
                        word.charAt(0).toUpperCase() + word.slice(1)
                    ).join(' ');
                    pdf.text(`${propName}: ${count}`, 40, yPos); // Increased left margin
                    yPos += 50; // Increased spacing between items
                }
                
                // Save the PDF
                pdf.save(`stage-layout-${new Date().toISOString().split('T')[0]}.pdf`);
            });
        }

        // Add click handler for PDF export button
        document.querySelector('.export-pdf-button').addEventListener('click', exportLayoutPDF);

        // Update the slider input handler to ensure proper value synchronization
        sliders.forEach(slider => {
            const container = slider.parentElement;
            const numberInput = container.querySelector('.brightness-input');
            
            slider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                numberInput.value = value;
                updateSpotlightOpacity(slider, value);
                
                // Enable save button when changes are made
                if (currentScene) {
                    saveSceneBtn.disabled = false;
                }
            });

            numberInput.addEventListener('input', (e) => {
                let value = parseInt(e.target.value);
                value = Math.min(10, Math.max(0, value));
                e.target.value = value;
                slider.value = value;
                updateSpotlightOpacity(slider, value);
                
                // Enable save button when changes are made
                if (currentScene) {
                    saveSceneBtn.disabled = false;
                }
            });
        });

        // Add autoplay functionality
        let autoplayInterval = null;
        let isPlaying = false;

        function toggleAutoplay() {
            const button = document.querySelector('.autoplay-button');
            
            if (isPlaying) {
                stopAutoplay();
            } else {
                startAutoplay();
            }
            
            button.classList.toggle('playing');
            button.textContent = isPlaying ? 'Stop' : 'Autoplay';
        }

        function startAutoplay() {
            if (Object.keys(scenes).length < 2) {
                alert('Need at least 2 scenes for autoplay');
                return;
            }

            isPlaying = true;
            const shouldLoop = document.getElementById('loop-autoplay').checked;
            let sceneNames = Object.keys(scenes);
            let currentIndex = Math.max(0, sceneNames.indexOf(currentScene));

            function playNextScene() {
                if (!isPlaying) return; // Check if still playing
                
                currentIndex++;
                if (currentIndex >= sceneNames.length) {
                    if (shouldLoop) {
                        currentIndex = 0;
                    } else {
                        stopAutoplay();
                        return;
                    }
                }

                const nextSceneName = sceneNames[currentIndex];
                loadScene(nextSceneName);
                
                // Schedule next scene using current scene's transition time
                const transitionTime = (scenes[nextSceneName].transitionTime || 5) * 1000;
                setTimeout(playNextScene, transitionTime);
            }

            // Initial load if no scene is active
            if (!currentScene) {
                currentScene = sceneNames[0];
                loadScene(currentScene);
            }

            // Start with current scene's transition time
            const initialTransitionTime = (scenes[currentScene].transitionTime || 5) * 1000;
            setTimeout(playNextScene, initialTransitionTime);
        }

        function stopAutoplay() {
            isPlaying = false;
            clearInterval(autoplayInterval);
            autoplayInterval = null;
        }

        // Add event listeners
        document.querySelector('.autoplay-button').addEventListener('click', toggleAutoplay);

        // Stop autoplay when manual scene changes are made
        const originalLoadScene = loadScene;
        loadScene = function(sceneName) {
            if (isPlaying && autoplayInterval) {
                stopAutoplay();
                document.querySelector('.autoplay-button').classList.remove('playing');
                document.querySelector('.autoplay-button').textContent = 'Autoplay';
            }
            originalLoadScene(sceneName);
        };

        // Save autoplay settings to localStorage
        function saveAutoplaySettings() {
            const settings = {
                loopEnabled: document.getElementById('loop-autoplay').checked
            };
            localStorage.setItem('autoplaySettings', JSON.stringify(settings));
        }

        // Load autoplay settings from localStorage
        function loadAutoplaySettings() {
            const settings = JSON.parse(localStorage.getItem('autoplaySettings') || '{"loopEnabled": true}');
            document.getElementById('loop-autoplay').checked = settings.loopEnabled;
        }

        // Add event listeners for settings changes
        document.getElementById('loop-autoplay').addEventListener('change', saveAutoplaySettings);

        // Load settings when page loads
        loadAutoplaySettings();
    </script>
</body>
</html>
